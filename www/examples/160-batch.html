id: batch
title: Batching
tags: ts-req-batch, advanced
----
<p>This is a thing which is not immediately obvious, but is one of the reasons why
  TwinSpark appeared. It is an important optimization. Our use case for it was
  following: page renders for an anonymous user (for efficient caching on CDN) and
  then status of wishlisted products is checked. It's a pattern we use often and
  we really wanted it to be a first-class feature.</p>

<div class="card example">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span ts-data="campaign=123">
      <span ts-req-batch="/batch" ts-data="id=1" ts-trigger="visible">Span 1</span><br>
      <span ts-req-batch="/batch" ts-data="id=2" ts-trigger="visible">Span 2</span><br>
      <span ts-req-batch="/batch" ts-data="id=3" ts-trigger="visible">Span 3</span><br>
    </span>
  </p>

  <script type="text/html">
    <span>Updated Span 1 by request number</span>
    <span>Updated Span 2 by request number</span>
    <span>Updated Span 3 by request number</span>
  </script>
  <script>
    (function(markup) {
      var n = 1;
      XHRMock.get(/^\/batch\?/, function(req, res) {
        return res.status(200).body(markup.replace(/ number/g, ' number ' + n++));
      });
    })(prev());
    // how do I emulate "visibility" from intersection observer
    /*test*/(el => {
      wait(() => {
        var spans = el.$('span').children;
        tt.assert(spans[0].innerText.slice(10) == spans[0].innerText.slice(10));
      });
    })
  </script>
</div>
