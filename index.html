<!doctype html>
<html lang="en">
<head>
  <title>TwinSpark.js docs</title>
  <link rel="stylesheet" href="vendor/spectre.min.css">
  <link rel="icon" href="data:;base64,=">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="vendor/xhr-mock.js"></script>
  <link rel="stylesheet" href="vendor/highlight-foundation.min.css">
  <script src="vendor/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <script src="twinspark.js" data-timeout="5000" data-history="3"></script>
  <script>
    XHRMock.setup();

    XHRMock.delay = function(mock, ms) {
      return function (req, res) {
        var ret = typeof mock === 'function' ?
                  mock(req, res) :
                  res.status(mock.status || 200).body(mock.body);
        if (ret === undefined) return ret;
        return new Promise(resolve => setTimeout(() => resolve(ret), ms));
      }
    }

    function prev(n) {
      var el = document.currentScript.previousElementSibling;
      if (n == 2)
        el = el.previousElementSibling;
      return el.innerHTML;
    }

    function escape(s) {
      return s
        .replace(/&quot;/g, '"') // because json-in-attrs will be disgusting
        .replace(/&amp;/g, '&')
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function dedent(s) {
      var lines = s.split('\n');
      var offsets = lines.slice(1).map(line => line.search(/\S|$/));
      var offset = Math.min.apply(Math, offsets);
      var pat = new RegExp(`\n[\t ]{${offset}}`, 'g');
      s = s.replace(pat, '\n');
      return s;
    }

    function cleancode(s) {
      return escape(dedent((s || '').trim()));
    }

    function codewrap(s) {
      return '<pre><code>' + cleancode(s) +'</code></pre>';
    }

    function makeel(tag, attrs, content) {
      var el = document.createElement(tag);
      el.innerHTML = content;
      for (var k in attrs) {
        el.setAttribute(k, attrs[k]);
      }
      return el;
    }

    document.addEventListener('DOMContentLoaded', function() {
      [].forEach.call(document.querySelectorAll('.card'), function(card) {
        var example = card.querySelector('.card-body');
        example.initial = example.innerHTML;

        card.querySelector('.reset').addEventListener('click', function(e) {
          example.innerHTML = example.initial;
          twinspark.activate(example);
        });

        card.querySelector('.source').addEventListener('click', function(e) {
          /* var sources = card.querySelectorAll('script');
           * var html = '<h5>Example HTML</h5>' + codewrap(example.initial);
           * for (var i = 0; i < sources.length; i++) {
           *   var el = sources[i];
           *   var title = el.getAttribute('type') == 'text/html' ? 'Server response' : 'Tests/support scripts';
           *   html += '<hr><h5>' + title + '</h5>';
           *   html += codewrap(el.innerHTML);
           * }
           * example.innerHTML = html; */
          if (example.firstElementChild.tagName == 'PRE')
            return;
          example.innerHTML = codewrap(example.innerHTML);
          example.querySelectorAll('pre code').forEach(el => hljs.highlightElement(el));
        });
      });

      [].forEach.call(document.querySelectorAll('h3, h4'), function(el) {
        if (el.id && !el.querySelector('.anchor')) {
          var a = makeel('a', {href: '#' + el.id, className: 'anchor'}, '#');
          el.append(' ');
          el.append(a);
        }
      });
    });

  </script>
  <style>
    body {color: #333; }
    pre code {display: inline-block; } /* or else padding is broken for blocks */
    .card-body {overflow: auto; }
    .card-body > pre { margin-top: 0; }
    .btn-sm {margin-bottom: .2rem; }
    .mb-p {margin-bottom: 1.2rem; }
    .mt-p {margin-top: 1.2rem; }
    .fade {opacity: 0; transition: opacity 0.5s ease-in-out; }
  </style>
</head>
<body class="container">
<div class="columns">
<div class="column col-6 col-xl-8 col-lg-10 col-md-12 col-mx-auto">

<h1><a href="/">TwinSpark</a></h1>

<p>Declarative enhancement for HTML: simple, composable, lean. Only
  <a href="https://github.com/kasta-ua/twinspark-js/raw/master/dist/twinspark.min.js">8KB .min.gz</a>.
  That name comes from innovative
  <a href="https://en.wikipedia.org/wiki/TwinSpark">dual ignition engines</a>
  from Alfa Romeo — idea is that you work on client-side fluidity from both
  server- and client-side.</p>

<p>TwinSpark was heavily influenced
  by <a href="https://intercoolerjs.org/">Intercooler</a> (predecessor of
  <a href="https://htmx.org">htmx</a>) and was written since Intercooler's
  extensibility wasn't accomodating enough for our needs: we needed a way to
  integrate analytics and a "batch" request — when a lot of elements on page
  want to query same API.</p>

<p>Now it's a battle-tested technology used in a several companies. On
  a technical side, it got some nice properties:</p>
<ul>
  <li>No attribute inheritance — this is a big one, it keeps surprises away when
    you're developing.</li>
  <li><a href="">Actions</a> — a little async-transparent language to do some (limited)
    client-side scripting.</li>
  <li><a href="#batch">Batching</a> — very useful if you want to use HTTP
    caching effectively, while maintaining some personalisation for your
    users.</li>
  <li><a href="#validation">Morphing</a> — makes form validations and
    animations a breeze. Morphing tries to "save" HTML nodes from being
    replaced, so that focus, animations and state is kept. This is useful
    for form validation, for videos and sounds being played and so on. To use
    this effectively, mark important elements with
    <code>id="[unique-id]"</code>.</li>
</ul>

<p>See at <a href="https://github.com/kasta-ua/twinspark-js">Github</a>.</p>

<a href="https://github.com/kasta-ua/twinspark-js" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<!-- TESTS -->
<h2>Tests</h2>
<p>
  This document has tests embedded in examples, to run them, press:
  <button class="btn" onclick="runTests(event)">Run tests</button>
</p>
<style>
  #tinytest{font-family:sans-serif}
  #tinytest ul{margin:0 0 .5rem 1rem;padding-bottom:4px}
  #tinytest li{margin-top: .2rem;}
  #tinytest .duration{background: #c09853;
    padding: 2px 5px;
    font-size: .8rem;
    border-radius: 5px;
    box-shadow: inset 0 1px 1px rgba(0,0,0,.2);}
  #tinytest .test {margin-left: 2rem;}
  #tinytest summary{padding:4px}
  #tinytest .test.pass summary::before {
    content: '✓'; display: inline-block; margin-right: 5px; color: #00d6b2; }
  #tinytest .test.fail summary::before, #tinytest .test.error summary::before {
    content: '✖'; display: inline-block; margin-right: 5px; color: #c00; }
  #tinytest .test.error { background: #fcf2f2; }
</style>
<div id="tinytest"></div>
<script src="vendor/tinytest.js"></script>
<script>
  var TESTS = [];

  function makeTest(testfn) {
    var parent = document.currentScript.closest('div');
    var example = parent.querySelector('.card-body');
    var h = parent;
    while(h && !((h = h.previousElementSibling).tagName == 'H3')) {
    }

    return {
      name: h && h.innerText || 'test',
      func: async () => {
        example.innerHTML = example.initial;
        twinspark.activate(example);
        try {
          await testfn(example)
        } finally {
          example.innerHTML = example.initial;
          twinspark.activate(example);
        }
        return 1;
      }
      };
    }

    function test(testfn) {
      TESTS.push(makeTest(testfn));
    }

    // use to limit tests to only single function, so less noise happens when you
    // debug a test
    function test1(testfn) {
      var test = makeTest(testfn);
      setTimeout(_ => { TESTS = [test] }, 100);
    }

    function runTests(e) {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      Element.prototype.$ = Element.prototype.querySelector;
      Element.prototype.$$ = Element.prototype.querySelectorAll;
      window.event = (type, attrs, el) => {
        var e = new Event(type);
        if (attrs) Object.assign(e, attrs);
        el.dispatchEvent(e);
      }
      window.click = (el) => event('click', {button: 0}, el);
      window.wait = function(func, t) {
        return new Promise(resolve => setTimeout(() => resolve(func()), t || 16))
      }

      tt.test(TESTS);
    }

    window.addEventListener('run-twinspark-tests', runTests);
</script>
<!-- END TESTS -->


<hr>

<h2>Guide</h2>

<h3 id="fragment">Fragment updating</h3>
<p>The core feature of TwinSpark is it's ability to update fragments of the
  page using AJAX requests to server without writing JavaScript.</p>
<p>To simplify inner logic you have one limitation - you can only return single
  element from the server. If you return more, they will be ignored. How to deal
  with that and why it is so - read on.</p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/fragment" ts-req>Update me</a>
  </p>

  <script type="text/html">
    <a href="/fragment" ts-req>Updated!</a>
  </script>
  <script>
    XHRMock.get("/fragment", {body: prev()});
    test(el => tt.delay(1)
      .then(_ => click(el.$('a')))
      .then(_ => tt.delay(1))
      .then(_ => tt.assert('Element Updated!',
                           el.$('a').innerText == 'Updated!')));
  </script>
</div>


<h3 id="trigger" class="mt-p">Triggering requests</h3>
<p>Usually requests are triggered on natural interrupts: submit on forms and
  clicks elsewhere, but sometimes you want more, like triggering on being seen
  or hovered:</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/trigger" ts-req ts-trigger="mouseenter">Hover me!</a>
  </p>

  <script type="text/html">
    <a href="/trigger" ts-req>Zehr gut! :)</a>
  </script>
  <script>
    XHRMock.get("/trigger", {body: prev()});
    test(el => {
      event('mouseenter', null, el.$('a'));
      return wait(() => tt.assert(el.$('a').innerText == 'Zehr gut! :)'));
    });
  </script>
</div>


<h3 id="before" class="mt-p">Doing stuff before/after request</h3>
<p>If you need to do some custom things around your request, you can use
  <code>ts-req-before</code> and <code>ts-req-after</code>. Those use same
  syntax as <a href="#action"><code>ts-action</code></a>, so it's pretty
  flexible. One additional thing is that if last (or the only) command of
  <code>ts-req-before</code> returns falsy value (<code>false</code>, or
  an empty string, or a zero) - this stops that request.</p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/before" ts-req ts-req-before="delay 300">This will work with delay</a><br>
    <a href="/before" ts-req ts-req-before="prevent">This is prevented</a>
  </p>

  <script type="text/html">
    <a href="/before" ts-req>Did you see it?</a>
  </script>
  <script>
    XHRMock.get("/before", {body: prev()});
    test(el => {
      click(el.$$('a')[0])
      click(el.$$('a')[1])
      return wait(() => {
        tt.assert(el.$$('a')[0].innerText == 'Did you see it?')
        tt.assert(el.$$('a')[1].innerText == 'This is prevented')
      }, 320);
    });
  </script>
</div>


<h3 id="data" class="mt-p">Collecting data</h3>
<p>Sometimes collecting the data you need to send in templates is really
  annoying: you'll have to teach lower-level components/partials/etc some
  knowledge about higher levels. That is something TwinSpark can prevent: when
  you send a request, it iterates through element parents and searches for
  <code>ts-data</code> attributes, parses their content as query string or JSON
  and merges it into a single object. Note how values with same keys are aggregated
  into an array (like normal query string or form data). You can override that by
  specifying key with null or empty string (see demo source).</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span ts-data="a=1&b=2&c=3">
      <!-- empty c removes previous values of c and then adds 5 -->
      <a href="/data" ts-data="b=4&c&c=5" ts-req ts-req-method="POST">So. Much. Data.</a>
    </span>
  </p>

  <script>
    XHRMock.post("/data", function(req, res) {
      return res.status(200).body('<span>' + new URLSearchParams(req.body()).toString() + '</span>');
    });
   test(el => {
     click(el.$('a'));
     return wait(() => tt.assert(el.$('span').innerText == 'a=1&b=2&b=4&c=5'));
   });
  </script>
</div>


<h3 id="target" class="mt-p">Targeting other elements</h3>
<p>Often you don't want to replace clicked element, but some other part of the
  page, like if you hit "Refresh" and need to update big part of the page. This
  can be done with <code>ts-target</code> attribute, which takes a CSS
  selector.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span id="replace">I'm waiting...</span>
    <a href="/target" ts-req ts-target="#replace">Do it!</a>
  </p>

  <script type="text/html">
    <span id="#replace" class="text-success">Good catch!</span>
  </script>
  <script>
    XHRMock.get("/target", {body: prev()});
    test(el => {
      click(el.$('a'));
      return wait(() => tt.assert(el.$('span').innerText = 'Good catch!'));
    });
  </script>
</div>


<h3 id="parent" class="mt-p">Targeting parents</h3>
<p>Interestingly, this seems like the most common pattern - when a button needs
  to update an element around itself. Add modifier <code>parent</code> before
  selector and <code>element.closest(selector)</code> method will be used to
  find a parent. This will help a lot to minimize amount of ids.</p>

<p>There are a few other selector modifiers - please read sources of the function
  <code>_findSingleTarget</code> until we get proper documentation. They are here
  because regular CSS selectors start at the top of the document, but in case of
  TwinSpark you're starting from a concrete element. DOM has various APIs to do
  that, which TwinSpark maps to modifiers: <code>inherit</code>,
  <code>parent</code>, <code>child</code>, <code>sibling</code>.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>Wanna read text behind me?
      <a href="/parent" ts-req ts-target="parent p">Do it!</a>
    </p>
  </div>

  <script type="text/html">
    <p>Did you know that introducing too many ids is a symptom of coupling
      logic with markup?</p>
  </script>
  <script>
    XHRMock.get("/parent", {body: prev()});
    test(el => {
      click(el.$('a'));
      return wait(() => tt.assert(el.$('p').innerText.startsWith('Did you know')));
    });
  </script>
</div>


<h3 id="target-target" class="mt-p">Relative targeting</h3>
<p>Most twinspark commands and extensions operate directly on the current
  target element. However, some of them might require a pair of elements
  (e.g. a command that copies data from one input to another). This means
  supplying a twinspark selector as an argument. To point directly to
  the current target element, use the <code>target</code> keyword.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>Click here
      <input type="button" class="btn" ts-trigger="click" ts-action="valueToValue target 'parent .card-body | .result'" value="value" />
      or here
      <input type="button" class="btn" ts-trigger="click" ts-action="valueToValue target 'parent .card-body | .result'" value="another value" />
    </p>
    <p>to copy the value here:
      <input type="text" class="result" disabled /></p>
    <p>Click one of these buttons to rename it with the value above:
      <input type="button" class="btn" value="one" ts-trigger="click" ts-action="valueToValue 'parent .card-body | .result' target">
       or
       <input type="button" class="btn" value="two" ts-trigger="click" ts-action="valueToValue 'parent .card-body | .result' target">
    </p>
  </div>

  <script>
  twinspark.func({
    valueToValue: function (sourceSel, targetSel, o) {
      const source = twinspark.query(o.el, sourceSel);
      const target = twinspark.query(o.el, targetSel);
      target.value = source.value;
    },
  });
  </script>
</div>

<br/>
<p>Another useful target is the element that created the event. The simplest
  way to access it is to create a twinspark extension that sets
  <code>target</code> to <code>event.target</code>:</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <div ts-trigger="click" ts-action="prevent, targetSource, class^ active">
      <p>None of these buttons have <code>ts-actions</code>, but when you click,
        the event is bubbled to the container that executes commands:<br/>
        <a href="" class="btn">One</a>
        <a href="" class="btn">Two</a>
        <a href="" class="btn">Three</a>
      </p>
    </div>
  </div>

  <script>
  twinspark.func({
    targetSource: function (o) {
      o.el = o.event.target;
    },
  });
  </script>
</div>


<h3 id="history" class="mt-p">Changing URLs</h3>
<p>URLs are a fundament of the Web. Changing URLs in line with activity makes your
  app reloadable, browseable with backward/forward button and overall a good
  citizen of the Web.</p>
<p><i>NOTE:</i> twinspark is loaded with limit of 3 items in history storage (which
uses IndexedDB), so if you click all of those links and then go back you'll see
than it'll only restore HTML for the first 3 clicks</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/history" ts-req ts-req-history>Let's change history!</a>
  </p>
  <p class="card-body">
    <a href="/history2" ts-req ts-req-history>Let's change history 2!</a>
  </p>
  <p class="card-body">
    <a href="/history3" ts-req ts-req-history>Let's change history 3!</a>
  </p>
  <p class="card-body">
    <a href="/history4" ts-req ts-req-history>Let's change history 4!</a>
  </p>

  <script type="text/html">
    <span>Now check that back button works</span>
  </script>
  <script>
    XHRMock.get("/history", {body: prev()});
    XHRMock.get("/history2", {body: prev()});
    XHRMock.get("/history3", {body: prev()});
    XHRMock.get("/history4", {body: prev()});
    test(el => {
      click(el.$('a'));
      return wait(() => {
        tt.assert(location.pathname == '/history');
        history.replaceState(null, null, '/');
      });
    });
  </script>
</div>


<h3 id="indicator" class="mt-p">Indicating activity</h3>
<p>It's really irritating when you click a link and nothing happens for some time. Luckily
  TwinSpark makes it really easy: it adds class <code>ts-active</code> to an element, enhanced with <code>ts-req</code>.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/indicator" class="indicator" ts-req>Just click me</a>
  </p>

  <style>
    @keyframes border {
      0%   {left: 0;}
      51%  {left: calc(100% - 20px);}
      100% {left: 0;}
    }

    .indicator.ts-active {
      pointer-events: none;
      position: relative;
    }
    .indicator.ts-active::after{
      animation: border 1.5s infinite linear;
      position: absolute;
      width: 20px;
      height: 2px;
      bottom: -2px;
      left: 0;
      background: #807fe2;
      z-index: 1;
      content: "";
    }
  </style>

  <script type="text/html">
    <a href="/indicator" class="indicator" ts-req>Just click me</a>
  </script>
  <script>
    XHRMock.get("/indicator", XHRMock.delay({body: prev()}, 1000));
    test(el => {
      click(el.$('a'));
      return wait(() => tt.assert(el.$('a').classList.contains('ts-active')));
      // I'm too lazy to wait for so long
      //wait(() => tt.assert(!el.$('a').classList.contains('ts-active')), 1050);
    });
  </script>
</div>


<h3 id="actions" class="mt-p">Actions</h3>
<p>Sometimes you don't need to go to server to do something. Closing popup or
  hiding an element can be done without network round trip.</p>

<p>Default actions (those are defined in TwinSpark without you doing anything):</p>
<ul>
  <li><code>stop</code>: stops propagation of an event which triggered this action pipeline</li>
  <li><code>prevent</code>: prevents default reaction of an event which triggered this action pipeline</li>
  <li><code>delay [Ns]</code>: delays execution of an action pipeline by N seconds</li>
  <li><code>target ['selector']</code>: selects another element (based on current one, so you can use all selector modifiers)</li>
  <li><code>remove</code>: removes target element (current one by default)</li>
  <li><code>wait [event-name]</code>: waits for an event to happen on a target element</li>
  <li><code>class+ [class-name]</code>: adds a class to a target element</li>
  <li><code>class- [class-name]</code>: removes a class from a target element</li>
  <li><code>class^ [class-name]</code>: toggles a class on a target element</li>
  <li><code>not [command-name arg1 arg2]</code>: negates return value of a given command</li>
  <li><code>log [what ever you want]</code>: logs whatever you pass it, along with an input value if any</li>
</ul>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>remove</code></h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>
      Hey! I'm here!
      <button class="btn" ts-action="remove" ts-trigger="click" ts-target="parent p">Remove me!</button>
    </p>
  </div>

  <script>
    test(el => {
      click(el.$('button'));
      return wait(() => tt.assert('Removed', el.$('button') == null));
    });
  </script>
</div>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>delay</code></h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-target="child span">
      <span>Remove with timeout</span>
      <button class="btn" ts-action="class+ loading, delay 1s, remove" ts-target="inherit">Do it!</button>
    </p>
  </div>

  <script>
    test(el => {
      click(el.$('button'));
      return wait(() => tt.assert('Removed with timeout', el.$('button')));
      //wait(() => tt.assert(el.$('button')), 1050);
    });
  </script>
</div>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>wait</code> (waiting for an event to happen)</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>
      <span>Remove after transition</span>
      <button class="btn" ts-action="class+ fade, wait transitionend, remove" ts-target="sibling span">Do it!</button>
    </p>
  </div>

  <script>
    test(el => {
      click(el.$('button'));
      return wait(() => tt.assert('Not removed yet', el.$('button')));
      //wait(() => tt.assert(el.$('button')), 1050);
    });
  </script>
</div>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of <code>animate</code> (no Safari here)</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>
      <button class="btn" ts-action="anim">Animate</button>
    </p>
  </div>

  <script>
    twinspark.func({anim: function () {
      this.animate([{transform: "translate3D(0,0,0)"},
                    {transform: "translate3D(300px,0,0)"}],
                   {duration: 1000, iterations: 10})
    }});
    // i don't know if it's possible
    /*test*/(el => {
      click(el.$('button'));
      return wait(() => {
        console.log(getComputedStyle(el.$('button')).transform);
        tt.assert(getComputedStyle(el.$('button')).transform != 'none')
      }, 100);
    });
  </script>
</div>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo of multiple actions</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p class="remove-me">This is going to be removed</p>
    <p class="fade-me">And this only after transition</p>
    <button class="btn" ts-action="
      target 'sibling .remove-me', remove;
      target 'sibling .fade-me', class+ fade, wait transitionend, remove
    ">
      Double remove</button>
  </div>
</div>

<!--
     <h3 id="timer" class="mt-p">Extending with external function</h3>
     <p>In case you need to implement some weird functionality, there is an extension point to </p>


     <div class="card">
     <div class="card-header">
     <h5 class="d-inline mr-2">Demo (no Safari here)</h5>
     <button class="btn btn-link btn-sm reset">Reset</button>
     <button class="btn btn-link btn-sm source">View Source</button>
     </div>

     <div class="card-body">
     <p>
     <time datetime="2022-03-21T00:00:00Z" ts-action="timeUntil" ts-trigger="timeout 1000"></time>
     </p>
     </div>
     </div>
-->


<h3 id="visible" class="mt-p">Triggering on changed visibility</h3>
<p>Doing something when element is almost visible makes it possible to implement lazy
  loading and various analytical events</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-action="class+ loading, delay 5s, class- loading" ts-trigger="visible">
      You'll probably see this text after around 5 seconds or so. Click "Reset" to see
      loader again.
    </p>
    <p ts-action="log invisible!!!" ts-trigger="invisible">
      This sentence will log some message when it becomes invisible (moves out of
      browser viewport, and, actually, on load as well).
    </p>
  </div>
</div>


<h3 id="outside" class="mt-p">Handling clicks outside of an element</h3>
<p>Popups, modals, menus and some other elements can make use of <code>click
  happened outside</code>. It could be done with markup and underlying element,
  but why bother if you have straightforward trigger.</p>

<p>This trigger is ideally used with modifier <code>once</code>, since you're
  probably going to remove that modal you calling it on - using <code>once</code>
  will clean up your listeners so you won't get memory leaks.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-trigger="outside once"
       ts-action="target 'child a', text 'Outside, but just this one time'">
      <a href="#" ts-action="text 'Inside, every time'">No clicks yet.</a>
    </p>

    <p>
      <a href="#" ts-action="stop">Link to check that stopPropagation doesn't matter to <code>outside</code> clicks.</a>
    </p>
  </div>

  <script>
    test(el => {
      var a = el.$('a');
      return tt.delay()
        .then(_ => tt.assert('start: ' + a.innerText, a.innerText.startsWith('No clicks')))
        .then(_ => a.click())
        .then(_ => tt.delay())
        .then(_ => tt.assert('click inside: ' + a.innerText, a.innerText.startsWith('Inside')))
        .then(_ => el.click())
        .then(_ => tt.delay())
        .then(_ => tt.assert('outside: ' + a.innerText, a.innerText.startsWith('Outside')))
        .then(_ => a.click())
        .then(_ => tt.delay())
        .then(_ => tt.assert('inside: ' + a.innerText, a.innerText.startsWith('Inside')))
    });
  </script>
</div>


<hr>

<h2>Advanced</h2>

<h3 id="children">Dealing with multiple elements</h3>
<p>TwinSpark usually deals with single element being target (<code>ts-target</code>)
  and single element being replacement (<code>ts-req-selector</code>) - this is
  much more controlled behavior than multiple elements. But if you look how
  endless scrolling is implemented in HTML, it's usually a long list of elements
  inside some other element - so you have to deal with several elements being appended
  to a parent. For this and similar use cases there is a modifier <code>children</code>
  in <code>ts-req-selector</code>.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span class="list">
      <span class="chip">Element 1</span><br>
      <span class="chip">Element 2</span><br>
      <button class="btn" ts-req="/children" ts-req-selector="children .list">Load more</button>
    </span>
  </p>

  <script type="text/html">
    <span class="list">
      <span class="chip">Element 3</span><br>
      <span class="chip">Element 4</span><br>
    </span>
  </script>
  <script>
    XHRMock.get("/children", {body: prev()});
    test(el => {
      click(el.$('button'));
      return wait(() => {
          tt.assert(el.$$('.list span').length == 4)});
      });
  </script>
</div>


<h3 id="batch" class="mt-p">Batching requests</h3>
<p>This is a thing which is not immediately obvious, but is one of the reasons why
  TwinSpark appeared. It is an important optimization. Our use case for it was
  following: page renders for an anonymous user (for efficient caching on CDN) and
  then status of wishlisted products is checked. It's a pattern we use often and
  we really wanted it to be a first-class feature.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <span ts-data="campaign=123">
      <span ts-req-batch="/batch" ts-data="id=1" ts-trigger="visible">Span 1</span><br>
      <span ts-req-batch="/batch" ts-data="id=2" ts-trigger="visible">Span 2</span><br>
      <span ts-req-batch="/batch" ts-data="id=3" ts-trigger="visible">Span 3</span><br>
    </span>
  </p>

  <script type="text/html">
    <span>Updated Span 1 by request number</span>
    <span>Updated Span 2 by request number</span>
    <span>Updated Span 3 by request number</span>
  </script>
  <script>
    (function(markup) {
      var n = 1;
      XHRMock.get(/^\/batch\?/, function(req, res) {
        return res.status(200).body(markup.replace(/ number/g, ' number ' + n++));
      });
    })(prev());
    // how do I emulate "visibility" from intersection observer
    /*test*/(el => {
      wait(() => {
        var spans = el.$('span').children;
        tt.assert(spans[0].innerText.slice(10) == spans[0].innerText.slice(10));
      });
    })
  </script>
</div>


<h3 id="join" class="mt-p">Joining requests</h3>
<p>Sometimes you need to update more than a single point in your DOM tree.
  Maybe there is a basket item counter should be incremented, or a notification
  incoming. To perform that you need to add another tag in your HTML reply and
  indicate where it should go. There are two ways to do that: either by a
  selector in <code>ts-swap-push</code> attribute or by a `ts-swap-push` header.
  The latter has a form
  <code>[replace strategy]: [selector-in-document] <= [selector-in-response]</code></p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body" style="margin-bottom: 1.2rem" id="join-example">
    <div>
      <p class="primary">Update me!</p>
    </div>
    <div>
      <p class="secondary">And me!</p>
    </div>
    <div>
      <p class="tertiary">Also waiting here.</p>
    </div>
    <button class="btn"
            ts-req="/join"
            ts-target="#join-example .primary"
            ts-req-selector=".primary">
      Update them
    </button>
  </div>

  <script type="text/html">
    <p class="primary">Hey, you see this stuff?</p>
    <p class="secondary" ts-swap-push="#join-example .secondary">This one was pushed from server in attributes.</p>
    <p class="tertiary">And this one by a header.</p>
  </script>
  <script>
    XHRMock.get("/join",
                {body:    prev(),
                 headers: {'ts-swap-push': 'replace: #join-example .tertiary <= .tertiary'}});
  </script>
</div>

<h3 id="validation" class="mt-p">Dynamic form validation</h3>
<p>Form validation is a common task, and TwinSpark allows to consolidate
  validation logic on the server. Surprisingly, it could be difficult, but
  `ts-swap="morph"` strategy allows us to just return whole new form with errors
  and not mess up with focus.</p>
<p><mark>Imporant bits</mark>: input `id`s and that form submit appends
  <code>&lt;input type="submit"&gt;</code>'s value - this way you can distinguish between
  validation and submission. Notice how `keyup` updates form on every character
  input and it feels natural.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>
  <div class="card-body">
    <p>Solve this problem with odd numbers</p>
    <form action="/validate" id="form-validate"
          ts-req ts-swap="morph" ts-trigger="submit, keyup" ts-action="prevent">
      <div>
        <div class="form-number-div">
          <input id="one" name="one" value="8" type="number" placeholder="Odd" autocomplete="off">
          <div class="error"></div>
        </div>
        +
        <div class="form-number-div">
          <input id="two" name="two" value="" type="number" placeholder="Odd" autocomplete="off">
          <div class="error"></div>
        </div>
        = 14
      </div>
      <input type="submit" class="btn" value="submit" name="submit" />
      <div class="error"></div>
    </form>
    <br/>
  </div>

  <style>
    #form-validate .error { color: #f00; font-style:italic; }
    .form-number-div { display:inline-block; height: 60px; vertical-align: top; }
  </style>

  <script>
    (function(html) {
      var div = document.createElement('div');
      div.innerHTML = html;
      var form = div.querySelector('form');

      XHRMock.post(/\/validate/, XHRMock.delay(function(req, res) {
        var params = new URLSearchParams(req.body());
        var one = parseInt(params.get('one'), 10),
            two = parseInt(params.get('two'), 10);

        var errors = {}, ok = true;
        if (!one) {
          errors.global = 'Incorrect!';
          errors.one = 'Enter a number';
          ok = false;
        } else if (one % 2 == 0) {
          errors.global = 'Incorrect!';
          errors.one = 'Please enter odd number';
          ok = false;
        }

        if (!two) {
          errors.global = 'Incorrect!';
          errors.two = 'Enter a number';
          ok = false;
        } else if (two % 2 == 0) {
          errors.global = 'Incorrect!';
          errors.two = 'Please enter odd number';
          ok = false;
        }

        if (ok && (one + two != 14)) {
          errors.global = 'Incorrect! Sum of two numbers should be equal to 14, not ' + (one + two);
          ok = false;
        }

        form.querySelector('[name=one]').setAttribute('value', params.get('one'));
        form.querySelector('[name=two]').setAttribute('value', params.get('two'));
        form.querySelector('[name=one] + .error').innerText = errors.one || '';
        form.querySelector('[name=two] + .error').innerText = errors.two || '';

        if (params.get('submit')) {
          form.querySelector(':scope > .error').innerText = errors.global || '';
        }

        return res.status(200).body(form.outerHTML);
      }, 100))
    })(prev(2));
  </script>

</div>


<h3 id="remove-event" class="mt-p">Doing something when node is removed</h3>
<p>It is useful to do something when node is removed (especially if that's some child
  or even non-related node triggering that removal). It's possible, but not recommended
  to use often since performance characteristics of the code are not well
  understood.</p>


<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p ts-action="resurrect" ts-trigger="remove">
      When this paragraph is removed by clicking button, it will resurrect itself.
      <button ts-action="remove" ts-target="parent p">Remove</button>
    </p>
  </div>

  <script>
    twinspark.func({resurrect: function(o) {
      var parent = o.event.detail.record.target;
      var el = o.el;
      setTimeout(() => parent.appendChild(o.el), 200);
    }});
  </script>

</div>


<h3 id="return" class="mt-p">Check actions pipelining</h3>

<p>Actions pipe their return values into next action as <code>o.input</code>, check
  the source of the next example to see how it works.
</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body mb-p">
    <button class="btn" ts-action="echo interested?, log Are you">Click to log</button>
  </div>

  <script>
    twinspark.func({
      echo: function(msg, o) {
        return msg;
      }
    });

    test(el => {
      tt.assert('simple parsing',
                 twinspark.parseAction('just a test')[0].commands[0].name == 'just')
      tt.assert('a few actions',
                 twinspark.parseAction('command 1, command 2; action 2').length == 2)
      tt.assert('parses string completely',
                 twinspark.parseAction('this "is a string"')[0].commands[0].args[0] != 'is')
      tt.assert('ignores punctuation in strings',
                 twinspark.parseAction('you "want, this;", right?')[0].commands[0].args[0] == 'want, this;')
      // NOTE: double escape since `\"` for JS in a string is the same as `"`,
      // and there is nothing we can do. We need to provide literal backslash
      // to the parser
      tt.assert('check quoting escape',
                 twinspark.parseAction('this "is \\"a string"')[0].commands[0].args[0] == 'is "a string')
    });
  </script>
</div>


<h3 id="script" class="mt-p">Returning <code>script</code> elements in
  responses</h3>

<p>Setting <code>innerHTML</code> to a value which contains <code>script</code>
  element does not execute JavaScript inside that element. TwinSpark handles
  that for you, check it out.</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <p class="card-body">
    <a href="/script" ts-req>Update me with a script</a>
  </p>

  <script type="text/html">
    <span>Change!<script>(el => setTimeout(() => el.innerHTML = 'Double change!', 250))(document.currentScript.parentElement)</script></span>
  </script>

  <script>
    XHRMock.get("/script", {body: prev()});
    test(el => {
      click(el.$('a'));
      return wait(() => tt.assert('Updated', el.$('span').innerText == 'Double change!'), 300);
    });
  </script>
</div>


<hr>


<h2>Use cases</h2>

<h3 id="autocomplete">Writing autocomplete</h3>
<p>Autocomplete is interesting because it executes many things at once. Just look
  at the source, the interesting part is trigger modifiers - it does something only
  if user typed something (rather than just navigated field with cursor keys) and
  then stopped for 200 ms.
</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p><input type="text"
              name="q"
              ts-req="/autocomplete"
              ts-trigger="keyup changed delay 200"
              ts-target="#search-results"
              ts-swap="inner"
              placeholder="Search..."/></p>
    <div id="search-results"></div>
  </div>

  <script>
    XHRMock.get(/\/autocomplete/, function(req, res) {
      var q = req.url().query.q;
      var now = +new Date;
      return res.status(200).body('<div>' +
                      ('one two three four five six seven'
                        .split(' ')
                        .map(s => '<p>' + q + ' ' + s + ' ' + now + '</p>')
                        .join('')) +
                      '</div>');
    });
  </script>
</div>


<br/>
<h4 id="cancelling-autocomplete">Making it economical</h4>
<p>When autocomplete triggers a time-consuming operation (e.g. full-text search),
  the implementation above triggers numerous requests if the user types slow enough.
  If requests finish at different durations, an older request can override the
  latest. To avoid this, we need to abort the XHR using <code>ts-req-strategy="last"</code>.</p>
<p>Possible values for <code>ts-req-strategy</code> are:</p>
<ol>
  <li><code>first</code> prevent triggering new requests until the active one finishes
    (useful for forms)</li>
  <li><code>last</code> abort active request when a new one is triggered</li>
  <li><code>queue</code> (default) send requests as they are triggered</li>
</ol>
<br/>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body">
    <p>Every other request is slow</p>
    <p><input type="text"
              name="q"
              ts-req-strategy="last"
              ts-req="/cancelling-autocomplete"
              ts-trigger="keyup changed delay 100"
              ts-target="#search-results-2"
              ts-swap="inner"
              placeholder="Search..."/></p>
    <div id="search-results-2"></div>
  </div>

  <script>
    function delay(mock, ms) {
      return (req, res) =>
        Promise.resolve(mock(req, res)).then(val => {
          return new Promise(resolve => {
            const after = ms();
            console.debug('⌛ Delaying', Math.round(after, 2)/1000., 'sec');
            return setTimeout(() => resolve(val), after, true);
          });
        });
    };

    var counter = 0;

    XHRMock.get(/\/cancelling-autocomplete/, delay(function(req, res) {
      var q = ('Query ' + (counter+1)
               + ' (' + (counter % 2 === 0 ? 'fast' : 'slow') + '): '
               + req.url().query.q);
      var now = +new Date;
      return res.status(200).body('<div>' +
                      ('one two three four five six seven'
                        .split(' ')
                        .map(s => '<p>' + q + ' ' + s + ' ' + now + '</p>')
                        .join('')) +
                      '</div>');
    }, () => 500 + (counter++ % 2) * 2000));
  </script>
</div>


<h3 id="progressbar" class="mt-p">Progress bar</h3>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body mb-p">
    <div>
      <h3>Start progress</h3>
      <button class="btn" ts-req="/progress" ts-req-method="post" ts-target="parent div">
        Start job
      </button>
    </div>
  </div>

  <style>
    .bar-item {
      transition: width .2s ease-in-out;
    }
  </style>

  <script type="text/html">
    <div ts-req="/progress" ts-trigger="load delay 500">
      <h3>Job in progress</h3>
      <div class="bar bar-sm">
        <div id="pb1" class="bar-item" role="progressbar" style="width:XXX%;"></div>
      </div>
    </div>
  </script>

  <script type="text/html">
    <div>
      <h3>Job in progress</h3>
      <div class="bar bar-sm">
        <div id="pb1" class="bar-item" role="progressbar" style="width:100%;"></div>
      </div>
      <button class="btn" ts-req="/progress" ts-req-method="post" ts-target="parent div">
        Restart job
      </button>
    </div>
  </script>

  <script>
    (function(progress, end) {
      var state = 0;

      XHRMock.post('/progress', function(req, res) {
        state = 0;
        return res.status(200).body(progress.replace('XXX', state));
      });

      XHRMock.get('/progress', function(req, res) {
        state += Math.floor(Math.random() * 30);
        if (state >= 100)
          return res.status(200).body(end);
        return res.status(200).body(progress.replace('XXX', state));
      });
    })(prev(2), prev());
  </script>
</div>


<h3 id="filters" class="mt-p">Filters</h3>
<p>Filtering on ecommerce sites is a complex task. On one side you want it to be crawlable
  by Google, on the other if a user selected two filters one by one you'd like to see
  products, filtered by both. Naïve implementation will filter only one of them if
  a pause between clicks was short enough. It seems like the best way is form, full
  of links (so that Google/no-js envs can still use it), which toggle checkboxes when
  JS is enabled and auto-submit form.
</p>

<div class="card">
  <div class="card-header">
    <h5 class="d-inline mr-2">Demo</h5>
    <button class="btn btn-link btn-sm reset">Reset</button>
    <button class="btn btn-link btn-sm source">View Source</button>
  </div>

  <div class="card-body" ts-target="child .out">
    <form method="get" action="/filters" ts-target="inherit" ts-req>
      <div><b>Brand</b></div>
      <div class="filter">
        <input type="checkbox" name="brand" value="adidas">
        <a href="?brand=adidas" ts-action="togglebox, submit">Adidas</a>
      </div>
      <div class="filter">
        <input type="checkbox" name="brand" value="nike">
        <a href="?brand=nike" ts-action="togglebox, submit">Nike</a>
      </div>
      <div class="filter">
        <input type="checkbox" name="brand" value="puma">
        <a href="?brand=puma" ts-action="togglebox, submit">Puma</a>
      </div>
    </form>
    <hr>
    <p class="out">Selected filters: </p>
  </div>

  <script>
    twinspark.func({
      togglebox: function(o) {
        var box = o.el.parentElement.querySelector('[type="checkbox"]');
        box.checked = !box.checked;
      },
      submit: function(o) {
        twinspark.trigger(o.el.closest('form'), 'submit');
      },
    });
    XHRMock.get(/\/filters/, function(req, res) {
      return res.status(200).body('<p class="out">Selected filters: ' + req.url() + '</p>');
    });
  </script>

  <style>
    .filter [type="checkbox"] { display: none; }
  </style>
</div>


<!-- DEBUG, should be last -->

<div style="margin-top: 50vh"></div>
<style>
  #debug-requests {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    padding: 0.5em;
    width: 100vw;
    height: 64px;
    background-color: whitesmoke;
    border-top: 2px solid gray;
    transition: height .2s ease-in-out;
  }
  #debug-requests.show {
    height: 45vh;
    overflow: scroll;
  }
  #debug-requests ol, #debug-requests li { margin: 0; }
  .show .show_show, .show_hide { display: none; }
  .show .show_hide { display: inline; }
</style>
<div id="debug-requests">
  Server Requests
  <a class="show_show" href="#" ts-action="prevent, target #debug-requests, class+ show">↑ Show</a>
  <a class="show_hide" href="#" ts-action="prevent, target #debug-requests, class- show">↓ Hide</a>

  <div class="columns">
    <div class="column col-3">
      <ol id="debug-timeline" reversed>
      </ol>
    </div>
    <div id="debug-details" class="column col-9">
      <div class="d-hide">
      </div>
    </div>
  </div>

  <script>
    function switchResponse(id) {
      var active = window['debug-timeline'].querySelector('.active');
      active && active.classList.remove('active');

      var shown = window['debug-details'].querySelector(':scope > :not(.d-hide)');
      shown && shown.classList.add('d-hide');

      document.querySelector(`[rel="${id}"]`).classList.add('active');
      document.getElementById(id).classList.remove('d-hide');
    }

    (() => {
      var i = 0;
      const origSend = XMLHttpRequest.prototype.send;
      const origOpen = XMLHttpRequest.prototype.open;

      XMLHttpRequest.prototype.send = function(body) {
        this.requestBody = body;
        origSend.apply(this, arguments);
      };
      XMLHttpRequest.prototype.open = function(method, url) {
        this.addEventListener('load', function() {
          var id = `debug${i++}`;
          window['debug-timeline'].insertAdjacentHTML(
            'afterbegin',
            `<li><a style="cursor:pointer" rel="${id}" onclick="switchResponse('${id}')">
                     <code><b>${method}</b> ${url}</code>
               </a></li>`
          );
          window['debug-details'].insertAdjacentHTML(
            'afterbegin',
            `<div id="${id}" class="d-hide">
                 <div><code>${this.status} <b>${method}</b> ${url} (${new Date().toTimeString().split(' ')[0]})</code></div>
                 <div><b>Body:</b> <code>${this.requestBody || ''}</code></div>
                 <div><b>Response</b></div>
                 <pre style="margin-top:0"><code>${cleancode(this.responseText)}</code></pre>
               </div>`
          );
          hljs.highlightElement(document.querySelector(`#${id} pre code`));
          document.querySelector(`[rel="${id}"]`).click();
        });
        origOpen.apply(this, arguments);
      };
    })();
  </script>
</div>
